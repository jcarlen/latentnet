\name{latentnet-internal}
\title{Internal latentnet Objects}

\alias{DistMatrix}
\alias{InitErgmm.latentcov}
\alias{InitErgmm.latent}
\alias{InitErgmm.latentcluster}
\alias{ergmm.Cprepare.latent}
\alias{ergmm.getmodel.latent}
\alias{ergmm.getterms.latent}
\alias{ergmm.gettermnames.latent}
\alias{ergmm.latent}
\alias{ergmm.statseval.latent}
\alias{ergmm.latentplot}
\alias{mlpY.grad.plot}
\alias{mlpY.plot}
\alias{mlpYmdsZ.grad.plot}
\alias{mlpYmdsZ.plot}
%
\alias{ergmm.geodesicmatrix}
\alias{ergmm.geodesicmatrix.edgelist}
\alias{ergmm.latentcluster}
\alias{ergmm.MCMCacf}
\alias{ergmm.procAdj}
\alias{ergmm.procAdj.fcnt}
\alias{ergmm.statseval.latentcluster}
\alias{ergmm.statseval.latent1cluster}
\alias{is.latent}
\alias{is.latent.cluster}
\alias{klswitch.c}
\alias{latent.wrapper}
\alias{lpz.dist}
\alias{mcmc.diagnostics.default}
\alias{add.mcmc.mle.mle.ergmm}
\alias{add.mcmc.pmode.pmode.ergmm}
\alias{add.mkl.mbc.ergmm}
\alias{add.mkl.pos.ergmm}
\alias{as.mcmc.list.ergmm.par.list}
\alias{bayesmbc}
\alias{bayesmbc.MCMC.C}
\alias{best.avail.Z.K.ref.ergmm}
\alias{best.avail.Z.ref.ergmm}
\alias{cmp.lists}
\alias{coords.1D}
\alias{dlpY.deta.Bernoulli.logit}
\alias{dlpY.deta.binomial.logit}
\alias{dlpY.deta.fs}
\alias{dlpY.deta.Poisson.log}
\alias{dsclinvchisq}
\alias{ergmm.eta}
\alias{ergmm.EY}
\alias{ergmm.fit.deps}
\alias{ergmm.get.model}
\alias{ergmm.initvals} 
\alias{FIT_MLE}
\alias{getYm}
\alias{gmmajump}
\alias{GS.orth.matrix}
\alias{InitErgmm.absdiff}
\alias{InitErgmm.nodematch}
\alias{InitErgmm.receivercov}
\alias{InitErgmm.rreceiver}
\alias{InitErgmm.rsender}
\alias{InitErgmm.rsociality}
\alias{InitErgmm.sendercov}
\alias{InitErgmm.socialitycov} 
\alias{kief.wolf2.optim}
\alias{kief.wolf.optim}
\alias{klswitch.C} 
\alias{sum.lists}
\alias{switch.Q.K}
\alias{thin.ergmm}
\alias{trimmed.mean}
\alias{unpack.optim}
\alias{unstack.ergmm.par.list}
\alias{zero.list}
\alias{mlpY}
\alias{mlpY0}
\alias{mlpY0.grad}
\alias{mlpY.grad}
\alias{mlpYmdsZ}
\alias{mlpYmdsZ.grad}
\alias{mlpYnull}
\alias{mlpY.cluster}
\alias{mlpY.cluster0}
\alias{mlpY.cluster0.grad}
\alias{mlpY.cluster.grad}
\alias{mlpY.clustermdsZ}
\alias{mlpY.clustermdsZ.grad}
\alias{mlpY.clusternull}
\alias{mvimode}
\alias{ergmm.permutation}
\alias{plot.mcmc.ergmm}
\alias{print.raftery.diag.ergmm}
\alias{rergm.ergmm.latent}
\alias{rergm.ergmm.latent.sociomatrix}
\alias{ergmm.set.mfrow}
\alias{traceplot.ergmm}
\alias{ergmm.add.contours}
\alias{ergmm.drawcircle}
\alias{ergmm.drawpie}
\alias{ergmm.labelswitch}
\alias{ergmm.midarrow}
\alias{ergmm.plinfo.latent}
\alias{network.dyadcount}
\alias{robust.inverse}
%
% These need to be documented!
%
\alias{summary.statsmatrix.ergmm}
\alias{is.invertible}

\description{
  Internal latentnet functions.
}
%\usage{
%}
%\details{
%  Most of these are not to be called by the user.
%}
%\arguments{
% \item{\dots}{Type help(package="latentnet") to get started.}
%}
\seealso{ergmm}
\keyword{internal}
